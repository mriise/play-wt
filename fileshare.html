<body>

    <script type="module">
        import { Encoder, Decoder, encode } from 'https://cdn.jsdelivr.net/npm/cbor-x@1.5.8/+esm'

        const ADDR_NAME = "wtAddress";
        const CERTHASH_NAME = "wtCerthash";
        const FILEHASH_NAME = "wtFileHash";


        window.onload = () => {
            // load query param into fields
            (new URL(window.location.href)).searchParams.forEach((k, v) => document.getElementById(v).value = k)
        }

        window.webtransportClick = async () => {
            let wtAddress = document.getElementById(ADDR_NAME).value;
            let wtCerthash = document.getElementById(CERTHASH_NAME).value;
            let wtFileHash = document.getElementById(FILEHASH_NAME).value;

            let certhash = Uint8Array.from(atob(base64URLto64(wtCerthash)), c => c.charCodeAt(0));
            let transport = new WebTransport(wtAddress, {
                serverCertificateHashes: [
                    {
                        algorithm: "sha-256",
                        value: certhash.buffer
                    }
                ]
            });

            console.log(transport)
            await transport.ready;

            // Create a bidirectional stream
            let stream = await transport.createBidirectionalStream();

            // readFromIncomingStream(stream.readable, 0);
            readIncomingSignaling(stream.readable, 0);
            receiveUnidirectional(transport);

            let writer = stream.writable.getWriter();

            let cbEncoder = new Encoder({ tagUint8Array: true });

            var rawData = {
                // needs to be array so it is encoded as array with individual unsigned so rust understands
                hash: Uint8Array.from(atob(base64URLto64(wtFileHash)), c => c.charCodeAt(0))
            };
            let data = encode(rawData);

            // console.log(btoa(String.fromCharCode(...new Uint8Array(data))))
            await writer.write(data)
            await writer.close();

            // TODO close out connection when done
            // await stream.readable.cancel();

        }

        function base64URLto64(data) {
            return data.replace(/_/g, '/').replace(/-/g, '+')
        }

        async function readIncomingSignaling(stream, number) {
            let d = new Decoder();
            let reader = stream.getReader();
            try {
                while (true) {
                    const { value, done } = await reader.read();
                    if (done) {
                        console.log('Stream #' + number + ' closed');
                        return;
                    }
                    // console.log(btoa(value));
                    // TODO large files dont go thru
                    let cborMessage = Object.fromEntries(d.decode(value).entries());
                    console.log(cborMessage);
                    console.log('Received data on stream #' + number + ': ' + cborMessage);

                    var opt = undefined;
                    if (cborMessage.mime !== "") {
                        opt = {type: cborMessage.mime};
                    }

                    if (window.downloading !== undefined) {
                        console.error("Sorry, only one file at a time for now");
                        return;
                    } 
                    window.downloading = cborMessage;
                    
                    // console.log(file);
                    // saveBlob(file, cborMessage.filename);
                }
            } catch (e) {
                console.error(
                    'Error while reading from stream #' + number + ': ' + e, 'error');
            }
        }

        async function receiveUnidirectional(transport) {
            const uds = transport.incomingUnidirectionalStreams;
            const reader = uds.getReader();
            while (true) {
                const { done, value } = await reader.read();
                if (done) {
                    break;
                }
                // value is an instance of WebTransportReceiveStream
                await readUni(value);
            }
        }

        async function readUni(receiveStream) {
            while (window.downloading === undefined) {
                await new Promise(r => setTimeout(r, 100)); 
            }
            let fileInfo = window.downloading;
            // prep file for saving
            let filenameSplit = fileInfo.filename.split('.');
            let ext = "." + filenameSplit.pop();
            let filename = filenameSplit.join(".");
            // save dialoge opt
            const opts = {
                excludeAcceptAllOption: true,
                // TODO: id maybe? https://developer.mozilla.org/en-US/docs/Web/API/Window/showSaveFilePicker#id
                // id: 1234
                startIn: "downloads",
                suggestedName: filename,
                types: [
                    {
                        accept: { [fileInfo.mime]: [ext] },
                    },
                ],
            };
            let file = await window.showSaveFilePicker(opts);

            // console.log(file, file.createWritable());

            const reader = receiveStream.getReader();
            const writer = await file.createWritable();
            while (true) {
                const { done, value } = await reader.read();
                if (done) {
                    // file download completed
                    console.info("uni stream finished")
                    writer.close()
                    window.downloading = undefined;
                    break;
                }
                // value is a Uint8Array
                // console.log(value);
                writer.write(value);
            }
        }

        window.shareClick = async () => {
            let shareURL = new URL(window.location.href);
            shareURL.search = "";

            shareURL.searchParams.append(ADDR_NAME, document.getElementById(ADDR_NAME).value);
            shareURL.searchParams.append(CERTHASH_NAME, document.getElementById(CERTHASH_NAME).value);
            shareURL.searchParams.append(FILEHASH_NAME, document.getElementById(FILEHASH_NAME).value);

            // copy to clipboard
            navigator.clipboard.writeText(shareURL.href);
            let oldText = document.getElementById("shareButton").innerText;
            document.getElementById("shareButton").innerText = "copied!"

            // reset text
            await new Promise(r => setTimeout(r, 2000));
            document.getElementById("shareButton").innerText = oldText;
        }

        window.saveAs = async () => {
            const opts = {
                excludeAcceptAllOption: true,
                // TODO: id maybe? https://developer.mozilla.org/en-US/docs/Web/API/Window/showSaveFilePicker#id
                // id: 1234
                startIn: "downloads",
                suggestedName: "shit",
                types: [
                    {
                        accept: { "text/plain": [".txt"] },
                    },
                ],
            };
            let file = await window.showSaveFilePicker(opts);

            console.log(file, file.createWritable());
        }

        var saveBlob = (blob, fileName) => {
            var a = document.createElement("a");
            document.getElementById("downloads").appendChild(a);
            a.innerText = "Download: " + fileName
            a.style.padding = "5px";

            const url = window.URL.createObjectURL(blob);
            a.href = url;
            a.download = fileName;
            // dont auto download
            // a.click();
            // a.remove()
            // window.URL.revokeObjectURL(url);
        };

    </script>

    <style>
        body {
            font-family: 'Courier New', Courier, monospace;
        }

        label {
            font-weight: bold;
            font-size: large;
        }

        form button {
            width: 200px;
            font-size: medium;
        }

        form {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }
    </style>

    <form onsubmit="return false">
        <label for="wtAddress">Address and Port</label>
        <input type="text" id="wtAddress" placeholder="Address" value="https://127.0.0.1:4433">
        <label for="wtCerthash">Certhash</label>
        <input type="text" id="wtCerthash" placeholder="Certhash" style="width: 450px;">
        <label for="wtFileHash">File Hash</label>
        <input type="text" id="wtFileHash" placeholder="File Hash" style="width: 450px;">
        <button onclick="window.webtransportClick()">fetch</button>
        <button onclick="window.shareClick()" id="shareButton">share</button>
    </form>

    <button onclick="window.saveAs()">save</button>

    <div id="downloads" style="display: flex; flex-direction: column;"></div>
</body>